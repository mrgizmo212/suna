# Developer Guide

This guide provides a detailed walk through of the repository so new contributors understand how each part fits together. It also lists every location where the Daytona sandbox provider is referenced and outlines a migration strategy to replace it with an open‑source alternative such as e2b or CodeSandbox.

## Directory Overview

```
backend/       - FastAPI application, background workers, sandbox logic
frontend/      - Next.js web client
docs/          - Project documentation
setup.py       - Interactive setup wizard
start.py       - Helper to start/stop Docker services
```

### Backend Structure

* **api.py** – Creates the FastAPI app, configures CORS, and registers API routes.
* **run_agent_background.py** – Dramatiq worker that processes queued agent jobs.
* **agent/** – Core agent logic.
  * `run.py` orchestrates tool calls and streams output.
  * `prompt.py` and `gemini_prompt.py` store prompt templates.
  * `tools/` includes browser automation (`sb_browser_tool.py`), shell commands (`sb_shell_tool.py`), file management (`sb_files_tool.py`), deployment helpers and more. These tools inherit from `sandbox/tool_base.py` to run inside a sandbox container.
* **agentpress/** – Higher level abstractions for managing conversations, invoking tools, and processing responses. Key files are:
  * `context_manager.py` – Maintains tool context between agent steps.
  * `thread_manager.py` – Keeps track of conversation threads.
  * `tool.py` and `tool_registry.py` – Define tools and register them for agent use.
* **sandbox/** – Remote execution environment.
  * `sandbox.py` wraps the `daytona_sdk` client to create/start sandboxes.
  * `tool_base.py` provides helper methods for tools to access the current sandbox.
  * `api.py` runs inside each sandbox to expose REST endpoints for file and browser operations.
  * `docker/` holds the Dockerfile, entrypoint script, and compose file for the sandbox image.
* **services/** – Helpers used across the backend.
  * `supabase.py` – Async Supabase database client.
  * `redis.py` – Redis connection utilities.
  * `llm.py` – Wrapper around LiteLLM for LLM providers.
  * `billing.py` – Stripe integration.
  * `docker/` – Scripts for publishing Docker images.
* **utils/** – Miscellaneous utilities.
  * `config.py` – Loads environment variables and exposes typed configuration.
  * `logger.py` – Logging helper used throughout the backend.
  * `files_utils.py`, `auth_utils.py` – File and authentication helpers.
  * `scripts/` – Maintenance scripts executed manually.

### Frontend

The `frontend/` directory contains a Next.js application that communicates with the backend API. Static assets live under `frontend/public/`. Environment variables are loaded from `.env.local` which is generated by the setup wizard.

### Setup and Startup

Running `python setup.py` guides the user through configuring Supabase, Daytona, and LLM credentials. The script writes `.env` files for the backend (`backend/.env`) and frontend (`frontend/.env.local`). After configuration, `python start.py` launches the Docker Compose stack defined in `docker-compose.yaml`.

## Daytona Integration Points

Daytona is currently used as the sandbox provider. References appear in the following locations:

1. **Environment Variables** – `DAYTONA_API_KEY`, `DAYTONA_SERVER_URL`, and `DAYTONA_TARGET` in `.env.example` and `utils/config.py`.
2. **Setup Wizard** – The `collect_daytona_info()` function in `setup.py` prompts for Daytona credentials.
3. **Sandbox Implementation** – `sandbox/sandbox.py` imports `daytona_sdk` and manages sandbox creation, starting, and command execution.
4. **Tools** – Classes in `agent/tools/` rely on `SandboxToolsBase` which calls `get_or_start_sandbox` in `sandbox/sandbox.py`.
5. **Utility Scripts** – Scripts under `utils/scripts/` import `daytona` from `sandbox.sandbox` to archive or delete sandboxes.
6. **Documentation** – Daytona setup instructions appear in `README.md` and `docs/SELF-HOSTING.md`.
7. **Dependencies** – `daytona_sdk` is listed in `backend/pyproject.toml` and `backend/requirements.txt`.

## Relationships Between Components

1. The **FastAPI app** (`api.py`) exposes REST endpoints. Agents invoked via these endpoints queue work for the **Dramatiq worker** (`run_agent_background.py`).
2. The worker uses tools under **agent/tools/** which require a sandbox environment via **sandbox/tool_base.py**. This base class retrieves or creates a sandbox using **sandbox/sandbox.py**.
3. **Supabase** and **Redis** are initialised in `services/` modules and imported wherever needed. Agent state, project metadata, and sandbox IDs are stored in Supabase.
4. **Frontend** interacts with the API to display results and manage projects. Environment variables direct it to the backend URL and the Supabase instance.
5. **Maintenance scripts** in `utils/scripts/` use the same configuration and connect to the sandbox provider to clean up unused sandboxes.

## Migration Plan: Replacing Daytona

To adopt an open‑source provider such as e2b or CodeSandbox, the sandbox logic should be abstracted so the rest of the codebase remains unchanged. A recommended approach:

1. **Provider Interface**
   - Create `sandbox/providers/base.py` defining an abstract `SandboxProvider` with methods like `create_sandbox`, `start_sandbox`, `exec`, `upload_file`, and `delete_sandbox`.
   - Refactor `sandbox/sandbox.py` into `DaytonaProvider` implementing this interface.

2. **New Provider Implementation**
   - Add a module (`E2BProvider` or `CodeSandboxProvider`) implementing the same interface using the new provider’s API or SDK.
   - Include its dependency in `pyproject.toml` and `requirements.txt`.
   - Allow selection via an env var `SANDBOX_PROVIDER=daytona|e2b|codesandbox`.

3. **Update Tools and Scripts**
   - Modify `SandboxToolsBase` and utility scripts to call methods on the selected provider instead of importing `daytona` directly.

4. **Revise Configuration and Setup**
   - Replace `DAYTONA_*` keys in `config.py` with provider‑agnostic names (`SANDBOX_API_KEY`, `SANDBOX_SERVER_URL`, etc.).
   - Update `setup.py` to prompt for the chosen provider and credentials (replacing `collect_daytona_info`).
   - Adjust `.env.example` and documentation accordingly.

5. **Documentation & Docker**
   - Rewrite README and `docs/SELF-HOSTING.md` to describe the new provider and any changes to the sandbox Docker image or entrypoint.

6. **Data Migration**
   - If sandbox IDs are stored in the database, write a script to create corresponding workspaces on the new provider and update Supabase records.

Once this abstraction is implemented, self-hosted deployments can run on an open-source provider capable of supporting thousands of concurrent sandboxes.
