# Developer Guide

This guide provides a detailed walk through of the repository so new contributors understand how each part fits together. It also lists every location where the Daytona sandbox provider is referenced and outlines a migration strategy to replace it with an open‑source alternative such as e2b or CodeSandbox.

## Directory Overview

```
backend/       - FastAPI application, background workers, sandbox logic
frontend/      - Next.js web client
docs/          - Project documentation
setup.py       - Interactive setup wizard
start.py       - Helper to start/stop Docker services
```

### Backend Structure

* **api.py** – Creates the FastAPI app, configures CORS, and registers API routes.
* **run_agent_background.py** – Dramatiq worker that processes queued agent jobs.
* **agent/** – Core agent logic.
  * `run.py` orchestrates tool calls and streams output.
  * `prompt.py` and `gemini_prompt.py` store prompt templates.
  * `tools/` includes browser automation (`sb_browser_tool.py`), shell commands (`sb_shell_tool.py`), file management (`sb_files_tool.py`), deployment helpers and more. These tools inherit from `sandbox/tool_base.py` to run inside a sandbox container.
* **agentpress/** – Higher level abstractions for managing conversations, invoking tools, and processing responses. Key files are:
  * `context_manager.py` – Maintains tool context between agent steps.
  * `thread_manager.py` – Keeps track of conversation threads.
  * `tool.py` and `tool_registry.py` – Define tools and register them for agent use.
* **sandbox/** – Remote execution environment.
  * `sandbox.py` wraps the `daytona_sdk` client to create/start sandboxes.
  * `tool_base.py` provides helper methods for tools to access the current sandbox.
  * `api.py` runs inside each sandbox to expose REST endpoints for file and browser operations.
  * `docker/` holds the Dockerfile, entrypoint script, and compose file for the sandbox image.
* **services/** – Helpers used across the backend.
  * `supabase.py` – Async Supabase database client.
  * `redis.py` – Redis connection utilities.
  * `llm.py` – Wrapper around LiteLLM for LLM providers.
  * `billing.py` – Stripe integration.
  * `docker/` – Scripts for publishing Docker images.
* **utils/** – Miscellaneous utilities.
  * `config.py` – Loads environment variables and exposes typed configuration.
  * `logger.py` – Logging helper used throughout the backend.
  * `files_utils.py`, `auth_utils.py` – File and authentication helpers.
  * `scripts/` – Maintenance scripts executed manually.

### Frontend

The `frontend/` directory contains a Next.js application that communicates with the backend API. Static assets live under `frontend/public/`. Environment variables are loaded from `.env.local` which is generated by the setup wizard.

### Setup and Startup

Running `python setup.py` guides the user through configuring Supabase, Daytona, and LLM credentials. The script writes `.env` files for the backend (`backend/.env`) and frontend (`frontend/.env.local`). After configuration, `python start.py` launches the Docker Compose stack defined in `docker-compose.yaml`.

## Daytona Integration Points

Daytona is currently used as the sandbox provider. References appear in the following locations:

1. **Environment Variables** – `DAYTONA_API_KEY`, `DAYTONA_SERVER_URL`, and `DAYTONA_TARGET` in `.env.example` and `utils/config.py`.
2. **Setup Wizard** – The `collect_daytona_info()` function in `setup.py` prompts for Daytona credentials.
3. **Sandbox Implementation** – `sandbox/sandbox.py` imports `daytona_sdk` and manages sandbox creation, starting, and command execution.
4. **Tools** – Classes in `agent/tools/` rely on `SandboxToolsBase` which calls `get_or_start_sandbox` in `sandbox/sandbox.py`.
5. **Utility Scripts** – Scripts under `utils/scripts/` import `daytona` from `sandbox.sandbox` to archive or delete sandboxes.
6. **Documentation** – Daytona setup instructions appear in `README.md` and `docs/SELF-HOSTING.md`.
7. **Dependencies** – `daytona_sdk` is listed in `backend/pyproject.toml` and `backend/requirements.txt`.

## Relationships Between Components

1. The **FastAPI app** (`api.py`) exposes REST endpoints. Agents invoked via these endpoints queue work for the **Dramatiq worker** (`run_agent_background.py`).
2. The worker uses tools under **agent/tools/** which require a sandbox environment via **sandbox/tool_base.py**. This base class retrieves or creates a sandbox using **sandbox/sandbox.py**.
3. **Supabase** and **Redis** are initialised in `services/` modules and imported wherever needed. Agent state, project metadata, and sandbox IDs are stored in Supabase.
4. **Frontend** interacts with the API to display results and manage projects. Environment variables direct it to the backend URL and the Supabase instance.
5. **Maintenance scripts** in `utils/scripts/` use the same configuration and connect to the sandbox provider to clean up unused sandboxes.

## Migration Plan: Replacing Daytona

To adopt an open‑source provider such as e2b or CodeSandbox, the sandbox logic should be abstracted so the rest of the codebase remains unchanged. A recommended approach:

1. **Provider Interface**
   - Create `sandbox/providers/base.py` defining an abstract `SandboxProvider` with methods like `create_sandbox`, `start_sandbox`, `exec`, `upload_file`, and `delete_sandbox`.
   - Refactor `sandbox/sandbox.py` into `DaytonaProvider` implementing this interface.

2. **New Provider Implementation**
   - Add a module (`E2BProvider` or `CodeSandboxProvider`) implementing the same interface using the new provider’s API or SDK.
   - Include its dependency in `pyproject.toml` and `requirements.txt`.
   - Allow selection via an env var `SANDBOX_PROVIDER=daytona|e2b|codesandbox`.

3. **Update Tools and Scripts**
   - Modify `SandboxToolsBase` and utility scripts to call methods on the selected provider instead of importing `daytona` directly.

4. **Revise Configuration and Setup**
   - Replace `DAYTONA_*` keys in `config.py` with provider‑agnostic names (`SANDBOX_API_KEY`, `SANDBOX_SERVER_URL`, etc.).
   - Update `setup.py` to prompt for the chosen provider and credentials (replacing `collect_daytona_info`).
   - Adjust `.env.example` and documentation accordingly.

5. **Documentation & Docker**
   - Rewrite README and `docs/SELF-HOSTING.md` to describe the new provider and any changes to the sandbox Docker image or entrypoint.

6. **Data Migration**
   - If sandbox IDs are stored in the database, write a script to create corresponding workspaces on the new provider and update Supabase records.

Once this abstraction is implemented, self-hosted deployments can run on an open-source provider capable of supporting thousands of concurrent sandboxes.
=======
# Suna Developer Guide

This document gives developers an overview of the main pieces of the project and how they fit together. It also describes how to run the project locally and how to add a new sandbox provider.

## Module Overview

### Backend services (`backend/`)
- **API** (`api.py`): FastAPI service exposing REST endpoints used by the frontend. It manages threads, messages and authentication through Supabase.
- **Worker** (`run_agent_background.py`): Dramatiq worker consuming tasks via RabbitMQ to execute the agent logic in the background.
- **Services** (`services/`): Helpers for Supabase access, Redis caching, LLM providers and billing logic.

### Agent logic (`backend/agent` and `backend/agentpress`)
- Implements the conversation workflow. `run_agent` orchestrates tool usage and reasoning cycles.
- `agentpress` provides utilities for thread management, response processing and context management.

### Sandbox provider (`backend/sandbox`)
- Handles creation and lifecycle of isolated execution environments. The default implementation uses **Daytona** via the SDK in `sandbox.py`.
- Tools inside `sandbox/tools` (shell, files, browser, etc.) interact with the sandbox through its API.

### Frontend structure (`frontend/`)
- Next.js application (`src/`) with pages under `app/`, shared components in `components/` and hooks/contexts for state management.
- Communicates with the backend API and Supabase authentication from the browser.

### Setup scripts
- **`setup.py`** – interactive wizard that configures environment variables, Supabase and optional services.
- **`start.py`** – convenience script to start/stop the Docker Compose stack.

## Component Interaction

1. **API requests**: The frontend calls the FastAPI backend (port `8000`). Authentication and data persistence are handled by Supabase using the `basejump` schema (see migrations in `backend/supabase/migrations`).
2. **Background tasks**: Agent runs are queued via RabbitMQ and processed by the Dramatiq worker. Redis is used to store state and stream results back to the API.
3. **Sandbox execution**: The worker spins up or resumes a sandbox container through the provider (Daytona by default) and the agent tools operate inside that environment.

The architecture diagram in the README illustrates these relationships.

## Adding a New Sandbox Provider

1. Implement a module under `backend/sandbox` that exposes functions similar to `create_sandbox` and `get_or_start_sandbox` but using your provider's API/SDK.
2. Update `utils/config.py` to include any new environment variables required by the provider.
3. Adjust `docker-compose.yaml` or deployment configuration to supply those variables.
4. Register the new module in the agent tools or replace calls in existing code where Daytona is used.
5. Test by running the worker and ensuring containers are created and commands execute correctly.

## Running Suna Locally

The [Self-Hosting Guide](./SELF-HOSTING.md) contains the full setup instructions. In short:

```bash
python setup.py               # gather config and prepare env files
python start.py               # start or stop the Docker stack
```

For manual development you can start each service separately as shown below:

```bash
docker compose up redis rabbitmq -d
cd frontend && npm run dev      # frontend
cd backend && poetry run python3.11 api.py    # backend API in another terminal
cd backend && poetry run python3.11 -m dramatiq run_agent_background   # worker
```

Refer to the backend README for important environment variables such as `REDIS_HOST` and `RABBITMQ_HOST` when running services outside of Docker.
